[
  {
    "id": "binaryTree",
    "name": "Árvores Binárias",
    "description": "Aprenda sobre árvores binárias, percursos, operações e balanceamento.",
    "classes": [
      {
        "id": "1",
        "name": "Fundamentos de Árvores",
        "description": "...",
        "topics": [
          {
            "id": "1",
            "name": "O que são estruturas de dados hierárquicas",
            "content": [
              {
                "type": "text",
                "value": "Antes de estudarmos árvores binárias, precisamos compreender um conceito fundamental: estruturas de dados hierárquicas. Elas se diferenciam de estruturas lineares como listas e filas por representarem relações de \"pai e filho\" entre os elementos."
              },
              {
                "type": "text",
                "value": "Uma estrutura de dados hierárquica é uma forma de organizar os dados em níveis, de modo que alguns elementos são \"superiores\" ou \"mais gerais\" do que outros. Isso é diferente das estruturas lineares, onde os elementos estão organizados em sequência (como uma fila ou lista encadeada). Dessa forma, uma hierarquia pode ser representada por uma coleção de nós conectados por ligações direcionais, onde um nó pode ter vários filhos, mas apenas um pai, formando uma estrutura em forma de árvore invertida."
              },
              {
                "type": "text",
                "value": "Pense em uma lista de tarefas como uma estrutura linear: cada tarefa vem depois da anterior."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_1_1.png"
              },
              {
                "type": "text",
                "value": "Agora pense em uma organização de empresa: um diretor pode ter vários gerentes abaixo dele, e cada gerente tem sua própria equipe. Isso é uma estrutura hierárquica."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_1_2.png"
              },
              {
                "type": "text",
                "value": "Utilizar esse tipo de estrutura é ideal quando os dados têm relações de dependência ou inclusão, como:"
              },
              {
                "type": "text",
                "value": "<ul><li>Representar sistemas de arquivos,</li><li>Modelar expressões matemáticas compostas,</li><li>Criar árvores de decisão para jogos ou IA,</li><li>Construir índices de busca em banco de dados.</li></ul>"
              },
              {
                "type": "text",
                "value": "No próximo tópico, vamos aprender o que é uma árvore, uma das formas mais comuns e poderosas de estrutura de dados hierárquica. como ela se organiza e por que ela é tão importante no mundo da computação."
              }
            ]
          },
          {
            "id": "2",
            "name": "Definição de árvore",
            "content": [
              {
                "type": "text",
                "value": "Agora que você entende o que são estruturas hierárquicas, vamos estudar um dos modelos mais clássicos e úteis desse tipo de estrutura: a árvore. Presente em inúmeras aplicações na computação, a árvore é uma estrutura fundamental para organizar, pesquisar e manipular dados."
              },
              {
                "type": "text",
                "value": "<b>Definição de árvore:</b>"
              },
              {
                "type": "text",
                "value": "Uma árvore é uma estrutura de dados não linear, composta por arestas que seguem uma organização hierárquica.  Formalmente, definimos uma árvore T como um conjunto finito de zero ou mais nós tal que:"
              },
              {
                "type": "text",
                "value": "Se o número de nós for igual a zero, temos uma árvore vazia, ou <br> Se o número de nós for maior que 0"
              },
              {
                "type": "text",
                "value": "<ul><li>existe um nó especialmente denominado raiz de T</li><li>os nós restantes formam m ≥ 0 conjuntos disjuntos p1, p2 … pm, cada um desses conjuntos é uma árvore em si, chamada subárvore da raiz de T, ou simplesmente subárvore.</li></ul>"
              }
            ]
          },
          {
            "id": "3",
            "name": "Representação gráfica de uma árvore",
            "content": [
              {
                "type": "text",
                "value": "Há várias formas de representar árvores em estruturas de dados, e a escolha ideal depende do tipo de árvore e das operações que se deseja realizar.  Neste tópico, vamos conhecer algumas das formas mais comuns dessas representações, com base em diagramas e técnicas utilizadas na literatura clássica da computação."
              },
              {
                "type": "text",
                "value": "<b>Hierárquica:</b>"
              },
              {
                "type": "text",
                "value": "É a forma mais comum de representar uma árvore, inspirada na aparência natural das árvores invertidas, onde a raíz fica no topo e os filhos são desenhados abaixo do pai, de forma ramificada."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_3_1.png"
              },
              {
                "type": "text",
                "value": "<b>Diagrama de Venn:</b>"
              },
              {
                "type": "text",
                "value": "Um círculo representa cada nodo e seus nodos descendentes são inseridos dentro do círculo de seus pais."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_3_2.png"
              },
              {
                "type": "text",
                "value": "<b>Diagrama de Barras:</b>"
              },
              {
                "type": "text",
                "value": "Linhas são usadas para mostrar a hierarquia dos nós. A raiz possui a linha de maior tamanho e os nós irmãos possuem linhas de tamanhos iguais. Esse método é bastante utilizado na criação de índices de livros  e sua indentação é similar a usada em linguagens de programação."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_3_3.png"
              },
              {
                "type": "text",
                "value": "<b>Numeração pos níveis:</b>"
              },
              {
                "type": "text",
                "value": "O nó raiz recebe o número um e todos os nodos seguintes recebem uma numeração sequencial, sempre antecedidos pela numeração de seus nó pai. É uma representação fácil para identificar a profundidade de cada nó."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_3_4.png"
              },
              {
                "type": "text",
                "value": "<b>Representação por Aninhamento:</b>"
              },
              {
                "type": "text",
                "value": "Essa representação conts com sucessão de parênteses reproduz as relações entre os nós, aninhando um nó filho ao seu pai."
              },
              {
                "type": "image",
                "value": "courses/binaryTree_1_3_5.png"
              }
            ]
          },
          {
            "id": "4",
            "name": "Componentes e Propriedades de Árvores",
            "content": [
              {
                "type": "text",
                "value": "<strong>Nó:</strong>"
              },
              {
                "type": "text",
                "value": "O nó é a unidade básica de uma árvore. Ele pode armazenar informações (como números, letras, dados de um registro etc.) e pode se conectar a outros nós por meio de arestas. Um nó pode ter:<ul><li>Nenhum filho (nesse caso, é chamado de folha);</li><li>Um ou mais filhos (dependendo do tipo de árvore).</li></ul>"
              },
              {
                "type": "text",
                "value": "<strong>Aresta:</strong>"
              },
              {
                "type": "text",
                "value": "A aresta é a ligação entre dois nós, indicando uma relação de pai e filho. Elas são direcionais: vão do pai para o filho."
              },
              {
                "type": "text",
                "value": "<strong>Raiz:</strong>"
              },
              {
                "type": "text",
                "value": "A raiz é o primeiro nó da árvore, o ponto de partida da hierarquia. É o único nó que não possui pai. A raiz é o nó que está no nível mais alto da estrutura, e a partir dela todos os outros nós podem ser alcançados."
              },
              {
                "type": "text",
                "value": "<strong>Nó pai e nó filho:</strong>"
              },
              {
                "type": "text",
                "value": "Quando um nó está diretamente acima de outro na hierarquia, ele é chamado de pai, e o nó abaixo é seu filho. Cada nó (com exceção da raiz) possui exatamente um pai, mas pode ter vários filhos."
              },
              {
                "type": "text",
                "value": "<strong>Folha:</strong>"
              },
              {
                "type": "text",
                "value": "Um nó folha é um nó que não possui filhos, pois está no \"fim\" da estrutura."
              },
              {
                "type": "text",
                "value": "<strong>Irmãos:</strong>"
              },
              {
                "type": "text",
                "value": "Nós irmãos são aqueles que compartilham o mesmo pai. Eles estão no mesmo nível hierárquico, lado a lado na estrutura."
              },
              {
                "type": "text",
                "value": "<strong>Grau:</strong>"
              },
              {
                "type": "text",
                "value": "O grau de um nó é definido como o número de filhos diretos que ele possui. Já o grau da árvore é o maior grau encontrado entre todos os seus nós."
              },
              {
                "type": "text",
                "value": "<strong>Profundidade:</strong>"
              },
              {
                "type": "text",
                "value": "A profundidade de um nó é a distância (em número de arestas) entre ele e a raiz. A raiz tem profundidade 0, seus filhos têm profundidade 1, e assim por diante."
              },
              {
                "type": "text",
                "value": "<strong>Altura:</strong>"
              },
              {
                "type": "text",
                "value": "A altura de um nó é a maior distância entre ele e uma folha abaixo. A altura da árvore é a altura de sua raiz, ou seja, o número máximo de níveis que ela possui."
              },
              {
                "type": "text",
                "value": "<strong>Árvore balanceada:</strong>"
              },
              {
                "type": "text",
                "value": "Uma árvore se configura balanceada quando a altura das subárvores de qualquer nó não difere em mais do que uma unidade (ou está dentro de um limite definido), garantindo que a árvore permaneça aproximadamente equilibrada."
              }
            ]     
          }
        ]
      }, {
        "id": "2",
        "name": "Árvores Binárias",
        "description": "...",
        "topics": [
          {
            "id": "1",
            "name": "Definição de Árvore Binária",
            "content": [{
              "type": "text",
              "value": "Agora que você já entende o que é uma árvore, é hora de conhecer uma de suas variações mais importantes e amplamente utilizadas na computação: a árvore binária. Uma árvore binária é uma estrutura de dados hierárquica na qual cada nó pode ter no máximo dois filhos. Esses filhos são nomeados com base em sua posição:  esquerdo e direito."
            },
            {
              "type": "text",
              "value": "A definição estrutural de uma árvore binária pode ser expressa através da seguinte forma recursiva:"
            },
            {
              "type": "text",
              "value": "<ul><li>Uma árvore vazia (sem nós)</li><li>Ou composta por um nó raiz, que armazena um valor e aponta para duas outras árvores binárias (sua subárvore esquerda e sua subárvore direita).</li></ul>"
            },
            {
              "type": "text",
              "value": "Essa característica recursiva torna naturais as implementações de operações como inserção, busca, remoção e percursos, muitas vezes utilizando chamadas recursivas para navegar pelas subestruturas da árvore."
            },
            {
              "type": "text",
              "value": "Do ponto de vista da teoria dos grafos, a árvore binária é definida como um grafo acíclico, conexo e dirigido, onde cada nó possui grau máximo igual a 2. Isso significa que só pode haver um caminho único entre quaisquer dois nós distintos, e os ramos da árvore (arestas) são direcionados do nó pai para seus filhos. Cada ramo é representado por uma ligação direcionada e sem peso, reforçando a estrutura hierárquica da árvore."
            },
            {
              "type": "text",
              "value": "No próximo tópico, vamos explorar em mais detalhes os termos fundamentais que descrevem uma árvore binária: raiz, filhos, folhas, altura, profundidade e grau."
            }
          ]
          }, {
            "id": "2",
            "name": "Árvore Binária de Busca (BST)",
            "content": [
              {
                "type": "text",
                "value": "<strong>Árvore Binária de Busca:</strong>"
              },
              {
                "type": "text",
                "value": "Uma das estruturas mais importantes e amplamente utilizadas na computação é a <strong>Árvore Binária de Busca</strong>, também conhecida pela sigla <strong>BST</strong> (<em>Binary Search Tree</em>). Essa estrutura segue uma regra fundamental de ordenação: para cada nó N, todos os valores na subárvore esquerda de N são menores do que o valor armazenado em N, e todos os valores na subárvore direita de N são maiores."
              },
              {
                "type": "text",
                "value": "Essa regra é o que permite que a BST seja eficiente em operações de busca, inserção e remoção. Ao procurar um valor, por exemplo, podemos compará-lo com o valor do nó atual e decidir rapidamente se devemos ir para a subárvore esquerda (valores menores) ou direita (valores maiores), descartando metade dos dados a cada passo, de maneira semelhante à busca binária em vetores ordenados."
              },
              {
                "type": "text",
                "value": "<strong>Exemplo:</strong>"
              },
              {
                "type": "text",
                "value": "Visualize a seguinte árvore binária de busca:"
              },
              {
                "type": "image",
                "value": "courses/binaryTree_2_2_1.png"
              },
              {
                "type": "text",
                "value": "Observe que:<ul><li>Todos os valores à esquerda de 8 são menores que 8;</li><li>Todos os valores à direita de 8 são maiores que 8;</li><li>Isso vale recursivamente para todos os nós da árvore.</li></ul>"
              },
              {
                "type": "text",
                "value": "A eficiência da BST depende do seu balanceamento. Em casos ótimos, quando a árvore está balanceada, uma busca por um nó ocorre em tempo O(log n). Já nos piores casos, quando a árvore se torna muito inclinada, a complexidade das operações pode ser O(n)."
              },
              {
                "type": "text",
                "value": "No próximo tópico, exploraremos essas operações de busca, inserção e remoção em Árvores Binárias de Busca de forma mais aprofundada."
              }
            ]
          }, {
            "id": "3",
            "name": "Operações em BSTs",
            "content": [
              {
                "type": "text",
                "value": "Para cada uma das operações abaixo, vamos utilizar a estrutura base da árvore em Java:"
              },
              {
                "type": "text",
                "value": "<code>class Node {\n    int valor;\n    Node esquerdo, direito;\n\n    Node(int valor) {\n        this.valor = valor;\n        this.esquerdo = null;\n        this.direito = null;\n    }\n}</code>"
              },
              {
                "type": "text",
                "value": "<strong>Busca:</strong>"
              },
              {
                "type": "text",
                "value": "A operação de busca tem como objetivo localizar um determinado valor na árvore, comparando o valor procurado com o conteúdo do nó atual e decidindo se deve continuar pela subárvore à esquerda (caso o valor buscado seja menor) ou pela direita (caso seja maior), de forma recursiva."
              },
              {
                "type": "text",
                "value": "<code>public Node buscar(Node raiz, int valor) {\n    if (raiz == null || raiz.valor == valor)\n        return raiz;\n\n    if (chave < raiz.valor)\n        return buscar(raiz.esquerdo, valor);\n    else\n        return buscar(raiz.direito, valor);\n}</code>"
              },
              {
                "type": "text",
                "value": "<strong>Inserção:</strong>"
              },
              {
                "type": "text",
                "value": "A operação de inserção consiste em adicionar um novo nó respeitando a propriedade de ordenação da árvore. O algoritmo é semelhante ao da busca: percorre-se a árvore até encontrar um local nulo onde o novo valor possa ser inserido. Na regra geral das BSTs, valores repetidos não devem ser inseridos."
              },
              {
                "type": "text",
                "value": "<code>public Node inserir(Node raiz, int valor) {\n    if (raiz == null) {\n        return new Node(valor);\n    }\n\n    if (chave < raiz.valor)\n        raiz.esquerdo = inserir(raiz.esquerdo, valor);\n    else if (chave > raiz.valor)\n        raiz.direito = inserir(raiz.direito, valor);\n\n    return raiz;\n}</code>"
              },
              {
                "type": "text",
                "value": "<strong>Remoção:</strong>"
              },
              {
                "type": "text",
                "value": "A remoção é a operação mais complexa em uma BST, pois exige que a propriedade da árvore seja mantida após a exclusão de um nó. Existem três casos a considerar:<ul><li><strong>Caso 1 – Nó folha:</strong> Se o nó a ser removido não tem filhos, basta eliminá-lo.</li><li><strong>Caso 2 – Nó com um filho:</strong> O filho substitui diretamente o nó removido, conectando-se ao seu pai.</li><li><strong>Caso 3 – Nó com dois filhos:</strong> Substitui-se o nó pelo seu sucessor (menor elemento da subárvore direita) ou antecessor (maior elemento da subárvore esquerda). Após a substituição, remove-se o nó duplicado que foi copiado.</li></ul>"
              },
              {
                "type": "text",
                "value": "<code>public Node remover(Node raiz, int valor) {\n    if (raiz == null)\n        return null;\n\n    if (valor < raiz.valor) {\n        raiz.esquerdo = remover(raiz.esquerdo, valor);\n    } else if (chave > raiz.valor) {\n        raiz.direito = remover(raiz.direito, valor);\n    } else {\n        // Caso 1: Sem filhos\n        if (raiz.esquerdo == null && raiz.direito == null)\n            return null;\n\n        // Caso 2: Um filho\n        if (raiz.esquerdo == null)\n            return raiz.direito;\n        if (raiz.direito == null)\n            return raiz.esquerdo;\n\n        // Caso 3: Dois filhos\n        Node sucessor = encontrarMinimo(raiz.direito);\n        raiz.valor = sucessor.valor;\n        raiz.direito = remover(raiz.direito, sucessor.valor);\n    }\n\n    return raiz;\n}\n\nprivate Node encontrarMinimo(Node node) {\n    while (node.esquerdo != null)\n        node = node.esquerdo;\n    return node;\n}</code>"
              },
              {
                "type": "text",
                "value": "<strong>Complexidade das Operações:</strong>"
              },
              {
                "type": "text",
                "value": "De maneira geral, a complexidade das operações é proporcional à altura da árvore:<ul><li><strong>Melhor caso (árvore balanceada):</strong> O(log n)</li><li><strong>Pior caso:</strong> O(n)</li></ul>"
              }
            ]
          }
        ]
      },
      {
        "id": "3",
        "name": "Percursos em Árvores Binárias",
        "description": "...",
        "topics": [
          {
            "id": "1",
            "name": "Introdução aos Percursos em Árvores Binárias",
            "content": [
              {
                "type": "text",
                "value": "Imagine que você recebeu a missão de organizar a árvore genealógica de uma família. No topo dessa estrutura está o bisavô, ele é o início de tudo, a raiz da árvore. A partir dele, descendem filhos, netos e bisnetos, cada um ocupando sua posição em uma hierarquia familiar. Essa árvore é representada de forma visual, com cada pessoa ocupando um nó, e cada ligação entre pai e filho representada por uma aresta. Como em uma árvore binária, cada pessoa pode ter até dois filhos."
              },
              {
                "type": "text",
                "value": "Agora, imagine que você precisa listar o nome de todos os membros da família. A pergunta que surge é: <em>Qual a melhor forma de visitar todas as pessoas dessa árvore, sem esquecer ninguém e seguindo uma ordem lógica?</em>"
              },

              {
                "type": "text",
                "value": "Você pode começar pelo bisavô e visitar seus descendentes diretos primeiro... ou talvez prefira visitar os membros mais à esquerda da árvore antes dos outros... ou ainda, deixar para visitar cada pai apenas depois de visitar todos os seus filhos."
              },
              {
                "type": "text",
                "value": "Perceba que existem várias formas de percorrer essa estrutura, e cada uma dessas formas pode servir a um objetivo diferente: entender a ordem de nascimento, agrupar gerações, ou até calcular a profundidade da árvore genealógica. Essa situação nos leva a um conceito fundamental no estudo de árvores binárias: os percursos. Eles são estratégias que definem a ordem em que os nós da árvore serão visitados. Em outras palavras, são caminhos que seguimos para garantir que todos os elementos sejam explorados corretamente, de acordo com o propósito da operação."
              },
              {
                "type": "text",
                "value": "Existem diversos tipos de percurso, e cada um deles serve a propósitos diferentes. As três formas mais clássicas, e que veremos em detalhes mais adiante, são chamadas de <strong>pré-ordem (pre-order)</strong>, <strong>em ordem (in-order)</strong> e <strong>pós-ordem (post-order)</strong>. Elas são baseadas em uma abordagem recursiva, onde a visita a um nó é feita em um ponto diferente em relação às visitas aos seus filhos. Além delas, há também o <strong>percurso por nível (level-order)</strong>, que segue uma lógica mais próxima de uma fila."
              },
              {
                "type": "text",
                "value": "Nos próximos tópicos, veremos cada tipo de percurso em detalhe e aprender como e quando aplicar cada um."
              }
            ]
          },
          {
            "id": "2",
            "name": "Percurso Pré-Ordem (Pre-Order)",
            "content": [
              {
                "type": "text",
                "value": "Dentre os percursos mais utilizados, o <strong>percurso pré-ordem (pre-order)</strong> é um dos mais intuitivos e serve como base para várias aplicações práticas, como a cópia de uma árvore ou a geração de expressões prefixadas."
              },
              {
                "type": "text",
                "value": "O percurso em pré-ordem segue a seguinte lógica:"
              },
              {
                "type": "text",
                "value": "<ul><li>Visita o nó atual (raiz).</li><li>Percorre recursivamente a subárvore esquerda.</li><li>Percorre recursivamente a subárvore direita.</li></ul>"
              },
              {
                "type": "text",
                "value": "Ou seja, visitamos o nó antes de seus filhos, por isso o nome “pré”-ordem. Essa estratégia é útil, por exemplo, quando queremos salvar a estrutura de uma árvore para reconstruí-la mais tarde, pois a raiz de cada subárvore é processada antes de seus descendentes."
              },
              {
                "type": "text",
                "value": "Vamos ilustrar com um exemplo simples:"
              },
              {
                "type": "image",
                "value": "courses/binaryTree_3_2_1.png"
              },
              {
                "type": "text",
                "value": "Aplicando o percurso pré-ordem nessa árvore, temos a seguinte sequência de visita:"
              },
              {
                "type": "text",
                "value": "<strong>A → B → D → E → C → F</strong>"
              },
              {
                "type": "text",
                "value": "Observe que o nó raiz A é visitado primeiro, depois percorremos completamente a subárvore da esquerda (B, D, E), e por fim, a subárvore da direita (C, F)."
              },
              {
                "type": "text",
                "value": "<strong>Pseudocódigo do percurso pré-ordem:</strong>"
              },
              {
                "type": "text",
                "value": "<code>função preOrdem(nó):<br>&nbsp;&nbsp;&nbsp;&nbsp;se nó != nulo:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitar(nó.valor)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preOrdem(nó.esquerda)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preOrdem(nó.direita)</code>"
              },
              {
                "type": "text",
                "value": "Nesse código, a função visitar() representa qualquer ação que você deseje executar no momento da visita ao nó, como imprimir o valor, calcular uma soma, etc."
              }
            ]
          },
          {
            "id": "3",
            "name": "Percurso Em Ordem (In-Order)",
            "content": [
              {
                "type": "text",
                "value": "O percurso em ordem, também conhecido pelo termo em inglês <em>in-order traversal</em>, é uma das formas mais importantes de percorrer uma árvore binária, especialmente quando estamos trabalhando com árvores binárias de busca (BSTs). Isso porque, ao aplicarmos esse percurso em uma BST, obtemos os elementos em ordem crescente, o que é extremamente útil para visualização ordenada dos dados."
              },
              {
                "type": "text",
                "value": "De forma geral, o percurso em ordem segue a seguinte sequência recursiva:"
              },
              {
                "type": "text",
                "value": "<ul><li>Visitar a subárvore esquerda;</li><li>Visitar onó atual;</li><li>Visitar a subárvore direita.</li></ul>"
              },
              {
                "type": "text",
                "value": "Essa abordagem é natural se pensarmos que queremos processar os menores valores (à esquerda), depois o valor central, e por fim os maiores (à direita)."
              },
              {
                "type": "text",
                "value": "Considere a seguinte árvore binária de busca:"
              },
              {
                "type": "image",
                "value": "courses/binaryTree_3_3_1.png"
              },
              {
                "type": "text",
                "value": "Se aplicarmos o percurso em ordem, os nós serão visitados na seguinte sequência:"
              },
              {
                "type": "text",
                "value": "<strong>10 → 20 → 30 → 40 → 50 → 60 → 70</strong>"
              },
              {
                "type": "text",
                "value": "Observe que o resultado é uma lista de valores ordenados crescentemente, graças à estrutura da árvore binária de busca e à lógica do <em>in-order traversal</em>."
              },
              {
                "type": "text",
                "value": "<strong>Pseudocódigo para percurso em ordem:</strong>"
              },
              {
                "type": "text",
                "value": "<code>função emOrdem(nó):<br>&nbsp;&nbsp;&nbsp;&nbsp;se nó ≠ nulo:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emOrdem(nó.esquerda)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitar(nó.valor)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emOrdem(nó.direita)</code>"
              },
              {
                "type": "text",
                "value": "A função visitar() representa qualquer operação que se deseja realizar com o valor do nó."
              }
            ]
          },
          {
            "id": "4",
            "name": "Percurso Pós-Ordem (Post-Order)",
            "content": [
              {
                "type": "text",
                "value": "O percurso em pós-ordem é um dos três percursos profundos clássicos utilizados em árvores binárias, ao lado do pré-ordem e em ordem. Ele é especialmente útil em situações em que desejamos processar todos os descendentes de um nó antes de processar o próprio nó. Isso é particularmente importante em algoritmos de remoção de nós, liberação de memória ou avaliação de expressões."
              },
              {
                "type": "text",
                "value": "A ordem de visitação dos nós no pós-ordem é a seguinte:"
              },
              {
                "type": "text",
                "value": "<ul><li>Visita à subárvore esquerda;</li><li>Visita à subárvore direita;</li><li>Visita ao nó atual (raiz).</li></ul>"
              },
              {
                "type": "text",
                "value": "Essa ordem contrasta com o pré-ordem (onde o nó atual é visitado primeiro) e o em ordem (onde o nó é visitado entre as subárvores). Em termos simples, no pós-ordem o nó “espera” todos os seus filhos serem visitados antes de ser processado."
              },
              {
                "type": "text",
                "value": "Considere a seguinte árvore binária:"
              },
              {
                "type": "image",
                "value": "courses/binaryTree_3_2_1.png"
              },
              {
                "type": "text",
                "value": "Aplicando o percurso pós-ordem, a ordem de visita será:"
              },
              {
                "type": "text",
                "value": "<ol><li>Subárvore esquerda de A → B<ul><li>Subárvore esquerda de B → D → (visita D)</li><li>Subárvore direita de B → E → (visita E)</li><li>Visita B</li></ul></li><li>Subárvore direita de A → C<ul><li>Subárvore direita de C → F → (visita F)</li><li>Visita C</li></ul></li><li>Visita A</li></ol>"
              },
              {
                "type": "text",
                "value": "Resultado do percurso pós-ordem: <strong>D, E, B, F, C, A</strong>."
              },
              {
                "type": "text",
                "value": "Observe como todos os filhos de um nó são visitados antes dele mesmo, o que faz sentido em contextos como eliminação de nós em ordem segura."
              },
              {
                "type": "text",
                "value": "Pseudocódigo do percurso pós-ordem:"
              },
              {
                "type": "text",
                "value": "<code>função posOrdem(nó):<br>&nbsp;&nbsp;&nbsp;&nbsp;se nó ≠ nulo:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posOrdem(nó.esquerda)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posOrdem(nó.direita)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitar(nó.valor)</code>"
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "id": "hashTable",
    "name": "Tabelas Hash",
    "description": "Aprenda sobre tabelas hash.",
    "classes": [
      {
        "id": "1",
        "name": "Introdução à Tabelas Hash",
        "description": "Entenda o conceito de tabelas hash, sua estrutura e aplicações.",
        "topics": [
          {
            "id": "1",
            "name": "O que são tabelas hash",
            "content": [
              {
                "type": "text",
                "value": "Texto de introdução a tabelas hash"
              },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto do topico 1 aula 1" }
            ]
          },
          {
            "id": "2",
            "name": "aula 2",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          },
          {
            "id": "3",
            "name": "aula 3",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          },
          {
            "id": "4",
            "name": "aula 4",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          },
          {
            "id": "5",
            "name": "aula 5",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          },
          {
            "id": "6",
            "name": "aula 6",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          }
        ]
      },
      {
        "id": "2",
        "name": "Pilhas 2",
        "description": "Aprenda sobre os tipos de percursos: pré-ordem, em-ordem e pós-ordem.",
        "topics": [
          {
            "id": "1",
            "name": "aula 1",
            "content": [
              { "type": "text", "value": "Texto da aula 1 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 1 parte 2." }
            ]
          },
          {
            "id": "2",
            "name": "aula 2",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          }
        ]
      },
      {
        "id": "3",
        "name": "Pilhas 3",
        "description": "Explore operações como inserção, remoção e busca em árvores binárias.",
        "topics": [
          {
            "id": "1",
            "name": "aula 1",
            "content": [
              { "type": "text", "value": "Texto da aula 1 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 1 parte 2." }
            ]
          },
          {
            "id": "2",
            "name": "aula 2",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          }
        ]
      },
      {
        "id": "4",
        "name": "Pilhas 4",
        "description": "Descubra como as árvores binárias de busca organizam dados de forma eficiente.",
        "topics": [
          {
            "id": "1",
            "name": "aula 1",
            "content": [
              { "type": "text", "value": "Texto da aula 1 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 1 parte 2." }
            ]
          },
          {
            "id": "2",
            "name": "aula 2",
            "content": [
              { "type": "text", "value": "Texto da aula 2 parte 1" },
              {
                "type": "image",
                "value": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/binary-tree-to-DLL.png"
              },
              { "type": "text", "value": "Texto da aula 2 parte 2" }
            ]
          }
        ]
      }
    ]
  }
]
